<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Spring Mass Physics Simulator</title>
     <link rel="icon" type="image/png" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTEwLjUgMTUuNUwxMiAxNEwxMy41IDE1LjVMMTUgMTdIMThWMTVIMTZMMTQuNSAxMy41TDE2IDEyTDE0LjUgMTAuNUwxMyA5VjZIMTFWOUw5LjUgMTAuNUw4IDEyTDkuNSAxMy41TDggMTVINlYxN0g4TDkuNSAxNS41Wk0xMiAyMkM2LjQ3NyAyMiAyIDE3LjUyMyAyIDEyQzIgNi40NzcgNi40NzcgMiAxMiAyQzE3LjUyMyAyIDIyIDYuNDc3IDIyIDEyQzIyIDE3LjUyMyAxNy41MjMgMjIgMTIgMjJaTTQgMTJDNCAxNi40MTggNy41ODIgMjAgMTIgMjBDMTYuNDE4IDIwIDIwIDE2LjQxOCAyMCAxMkMyMCA3LjU4MiAxNi40MTggNCAxMiA0QzcuNTgyIDQgNCA3LjU4MiA0IDEyWiIgZmlsbD0iIzRBNkZGRiIvPgo8L3N2Zz4=">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #0f2027, #203a43, #2c5364);
            color: #e0f7fa;
            min-height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        header {
            text-align: center;
            padding: 20px;
            background: rgba(0, 20, 30, 0.7);
            border-bottom: 1px solid rgba(64, 224, 208, 0.3);
            position: relative;
            z-index: 10;
        }
        
        h1 {
            font-size: 2.8rem;
            margin-bottom: 8px;
            text-shadow: 0 2px 8px rgba(0,0,0,0.7);
            background: linear-gradient(to right, #00b4db, #0083b0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            letter-spacing: 1px;
        }
        
        .subtitle {
            color: #80deea;
            font-weight: 300;
            font-size: 1.1rem;
            max-width: 800px;
            margin: 0 auto;
            line-height: 1.6;
        }
        
        .container {
            display: flex;
            flex: 1;
            padding: 20px;
            gap: 25px;
            max-width: 1800px;
            margin: 0 auto;
            width: 100%;
        }
        
        .simulation-container {
            flex: 3;
            position: relative;
            background: rgba(10, 30, 40, 0.4);
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 12px 35px rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(64, 224, 208, 0.2);
            min-height: 500px; /* Add minimum height */
            height: 70vh; /* Make it take most of vertical space */
        }
        
        canvas {
            background: linear-gradient(160deg, #0d2b3a, #0a1e2b);
            display: block;
            border-radius: 16px;
            width: 100%;
            height: 100%;
        }
        
        .controls {
            flex: 1;
            background: rgba(15, 40, 55, 0.8);
            border-radius: 16px;
            padding: 25px;
            display: flex;
            flex-direction: column;
            gap: 25px;
            box-shadow: 0 12px 35px rgba(0, 0, 0, 0.4);
            max-height: calc(100vh - 180px);
            overflow-y: auto;
            border: 1px solid rgba(64, 224, 208, 0.2);
        }
        
        .control-group {
            background: rgba(25, 55, 75, 0.8);
            padding: 20px;
            border-radius: 12px;
            border-left: 5px solid #00b4db;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        
        h2 {
            margin-bottom: 18px;
            color: #00b4db;
            font-size: 1.4rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        h2 i {
            font-size: 1.2rem;
        }
        
        .slider-container {
            margin-bottom: 18px;
            position: relative;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-size: 1rem;
            color: #b2ebf2;
        }
        
        input[type="range"] {
            width: 100%;
            height: 10px;
            border-radius: 5px;
            background: linear-gradient(to right, #0083b0, #00b4db);
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: #e0f7fa;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 179, 219, 0.8);
            border: 2px solid #00b4db;
            transition: transform 0.2s;
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }
        
        .value-display {
            font-size: 0.95rem;
            color: #e0f7fa;
            text-align: right;
            margin-top: 6px;
            font-weight: 500;
        }
        
        .button-group {
            display: flex;
            gap: 12px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        
        button {
            flex: 1;
            padding: 12px 18px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(to right, #0083b0, #00b4db);
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            min-width: 120px;
        }
        
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0, 179, 219, 0.4);
        }
        
        button:active {
            transform: translateY(1px);
        }
        
        button.reset {
            background: linear-gradient(to right, #ff5252, #ff7675);
        }
        
        button.add {
            background: linear-gradient(to right, #4caf50, #66bb6a);
        }
        
        .presets {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 12px;
        }
        
        .preset-btn {
            padding: 10px 15px;
            font-size: 0.9rem;
        }
        
        .instructions {
            font-size: 0.95rem;
            line-height: 1.6;
            color: #b2ebf2;
        }
        
        .instructions ul {
            padding-left: 25px;
            margin-top: 15px;
        }
        
        .instructions li {
            margin-bottom: 12px;
            position: relative;
        }
        
        .instructions li:before {
            content: "•";
            color: #00b4db;
            position: absolute;
            left: -15px;
            font-size: 1.2rem;
        }
        
        .physics-info {
            background: rgba(0, 180, 219, 0.1);
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            border: 1px solid rgba(0, 180, 219, 0.3);
        }
        
        .physics-info h3 {
            color: #00b4db;
            margin-bottom: 10px;
            font-size: 1.1rem;
        }
        
        footer {
            text-align: center;
            padding: 18px;
            font-size: 1rem;
            color: #80deea;
            background: rgba(0, 20, 30, 0.7);
            border-top: 1px solid rgba(64, 224, 208, 0.2);
            z-index: 10;
        }
        
        .canvas-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.9);
            z-index: 2;
            pointer-events: none;
        }
        
        .canvas-overlay h3 {
            font-size: 1.3rem;
            margin-bottom: 10px;
            color: #00b4db;
        }
        
        .canvas-overlay p {
            margin-bottom: 5px;
            font-size: 1rem;
        }
        
        .stats {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.5);
            padding: 12px 18px;
            border-radius: 10px;
            font-size: 0.9rem;
            color: #b2ebf2;
            border: 1px solid rgba(64, 224, 208, 0.2);
        }
        
        .highlight {
            color: #00b4db;
            font-weight: bold;
        }
        
        @media (max-width: 1100px) {
            .container {
                flex-direction: column;
            }
            
            .controls {
                max-height: 400px;
            }
            
            h1 {
                font-size: 2.2rem;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1><i class="fas fa-atom"></i> Advanced Spring Mass Physics Simulator</h1>
        <p class="subtitle">Interactive physics simulation with real-time parameter adjustments. Explore Hooke's Law, damping, and harmonic motion in various spring-mass systems.</p>
    </header>
    
    <div class="container">
        <div class="simulation-container">
            <canvas id="simulationCanvas"></canvas>
            <div class="canvas-overlay">
                <h3>Active Simulation: <span id="current-preset">Double Pendulum</span></h3>
                <p>Drag masses to interact with the system</p>
                <p>Press spacebar to pause/resume</p>
            </div>
            <div class="stats">
                <div>FPS: <span id="fps" class="highlight">60</span></div>
                <div>Masses: <span id="mass-count" class="highlight">3</span></div>
                <div>Springs: <span id="spring-count" class="highlight">2</span></div>
            </div>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <h2><i class="fas fa-sliders-h"></i> Physics Parameters</h2>
                <div class="slider-container">
                    <label for="gravity">Gravity: <span id="gravity-value">9.8</span> m/s²</label>
                    <input type="range" id="gravity" min="0" max="20" step="0.1" value="9.8">
                </div>
                
                <div class="slider-container">
                    <label for="springConstant">Spring Constant: <span id="springConstant-value">150</span> N/m</label>
                    <input type="range" id="springConstant" min="10" max="500" step="5" value="150">
                </div>
                
                <div class="slider-container">
                    <label for="damping">Damping Coefficient: <span id="damping-value">3.0</span></label>
                    <input type="range" id="damping" min="0" max="15" step="0.1" value="3.0">
                </div>
                
                <div class="slider-container">
                    <label for="airResistance">Air Resistance: <span id="airResistance-value">0.05</span></label>
                    <input type="range" id="airResistance" min="0" max="0.2" step="0.005" value="0.05">
                </div>
                
                <div class="slider-container">
                    <label for="stiffness">Structural Stiffness: <span id="stiffness-value">1.0</span></label>
                    <input type="range" id="stiffness" min="0.1" max="2.0" step="0.05" value="1.0">
                </div>
            </div>
            
            <div class="control-group">
                <h2><i class="fas fa-cogs"></i> Simulation Controls</h2>
                <div class="button-group">
                    <button id="pauseBtn"><i class="fas fa-pause"></i> Pause</button>
                    <button id="resetBtn" class="reset"><i class="fas fa-redo"></i> Reset</button>
                    <button id="addMassBtn" class="add"><i class="fas fa-plus-circle"></i> Add Mass</button>
                </div>
                
                <div class="slider-container" style="margin-top: 15px;">
                    <label for="simulationSpeed">Simulation Speed: <span id="simulationSpeed-value">1.0</span>x</label>
                    <input type="range" id="simulationSpeed" min="0.1" max="3" step="0.1" value="1.0">
                </div>
            </div>
            
            <div class="control-group">
                <h2><i class="fas fa-shapes"></i> System Presets</h2>
                <div class="presets">
                    <button class="preset-btn" data-preset="double-pendulum"><i class="fas fa-code-branch"></i> Double Pendulum</button>
                    <button class="preset-btn" data-preset="chain"><i class="fas fa-link"></i> Chain</button>
                    <button class="preset-btn" data-preset="grid"><i class="fas fa-border-all"></i> Grid</button>
                    <button class="preset-btn" data-preset="soft"><i class="fas fa-circle"></i> Soft Body</button>
                    <button class="preset-btn" data-preset="bridge"><i class="fas fa-bridge"></i> Suspension Bridge</button>
                    <button class="preset-btn" data-preset="net"><i class="fas fa-volleyball-ball"></i> Elastic Net</button>
                </div>
            </div>
            
            <div class="control-group">
                <h2><i class="fas fa-info-circle"></i> Instructions & Physics</h2>
                <div class="instructions">
                    <ul>
                        <li><span class="highlight">Drag masses</span> to interact with the system</li>
                        <li>Adjust physics parameters in real-time using sliders</li>
                        <li>Try different system presets for unique behaviors</li>
                        <li>Press <span class="highlight">spacebar</span> to pause/resume simulation</li>
                        <li>Add custom masses with the "Add Mass" button</li>
                    </ul>
                    
                    <div class="physics-info">
                        <h3><i class="fas fa-flask"></i> Physics Principles</h3>
                        <p>This simulation models spring-mass systems using:</p>
                        <ul>
                            <li><span class="highlight">Hooke's Law</span>: F = -kx (spring force proportional to displacement)</li>
                            <li><span class="highlight">Damping</span>: Resistance proportional to velocity</li>
                            <li><span class="highlight">Newtonian Mechanics</span>: F = ma for mass acceleration</li>
                            <li><span class="highlight">Energy Conservation</span>: Kinetic ↔ Potential energy conversion</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <footer>
        <p>Advanced Spring Mass Simulation | Physics Engine | &copy; 2023 Interactive Physics Lab</p>
    </footer>
    
    <script>
        class Vector {
            constructor(x = 0, y = 0) {
                this.x = x;
                this.y = y;
            }
            
            add(v) {
                return new Vector(this.x + v.x, this.y + v.y);
            }
            
            subtract(v) {
                return new Vector(this.x - v.x, this.y - v.y);
            }
            
            multiply(scalar) {
                return new Vector(this.x * scalar, this.y * scalar);
            }
            
            magnitude() {
                return Math.sqrt(this.x * this.x + this.y * this.y);
            }
            
            normalize() {
                const mag = this.magnitude();
                if (mag === 0) return new Vector();
                return new Vector(this.x / mag, this.y / mag);
            }
            
            distanceTo(v) {
                const dx = this.x - v.x;
                const dy = this.y - v.y;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            dot(v) {
                return this.x * v.x + this.y * v.y;
            }
        }

        class Mass {
            constructor(position, mass, radius = 15, fixed = false) {
                this.position = position;
                this.prevPosition = new Vector(position.x, position.y);
                this.velocity = new Vector();
                this.acceleration = new Vector();
                this.mass = mass;
                this.radius = radius;
                this.fixed = fixed;
                this.force = new Vector();
                this.selected = false;
                this.temp = false;
            }
            
            applyForce(force) {
                this.force = this.force.add(force);
            }
            
            update(dt) {
                if (this.fixed) return;
                
                // Verlet integration for better stability
                if (dt > 0) {
                    const temp = this.position;
                    this.position = this.position.add(this.position.subtract(this.prevPosition))
                        .add(this.force.multiply(dt * dt / this.mass));
                    this.prevPosition = temp;
                    
                    // Calculate velocity for damping
                    this.velocity = this.position.subtract(this.prevPosition).multiply(1/dt);
                }
                
                // Reset force accumulator
                this.force = new Vector();
            }
            
            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2);
                
                if (this.selected) {
                    ctx.fillStyle = '#ffeb3b';
                    ctx.strokeStyle = '#ff9800';
                    ctx.lineWidth = 3;
                } else if (this.fixed) {
                    ctx.fillStyle = '#f44336';
                    ctx.strokeStyle = '#b71c1c';
                } else if (this.temp) {
                    ctx.fillStyle = '#ab47bc';
                    ctx.strokeStyle = '#7b1fa2';
                } else {
                    const gradient = ctx.createRadialGradient(
                        this.position.x, this.position.y, 1,
                        this.position.x, this.position.y, this.radius
                    );
                    gradient.addColorStop(0, '#64b5f6');
                    gradient.addColorStop(0.7, '#2196f3');
                    gradient.addColorStop(1, '#0d47a1');
                    ctx.fillStyle = gradient;
                    ctx.strokeStyle = '#0d47a1';
                }
                
                ctx.fill();
                ctx.stroke();
                
                // Draw mass indicator
                if (!this.temp) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(`${this.mass.toFixed(1)}kg`, this.position.x, this.position.y);
                }
            }
        }

        class Spring {
            constructor(mass1, mass2, k, damping, restLength = null) {
                this.mass1 = mass1;
                this.mass2 = mass2;
                this.k = k;
                this.damping = damping;
                this.restLength = restLength || mass1.position.distanceTo(mass2.position);
                this.stiffness = 1.0;
            }
            
            update() {
                const delta = this.mass2.position.subtract(this.mass1.position);
                const displacement = delta.magnitude() - this.restLength;
                const direction = delta.normalize();
                
                // Spring force (Hooke's Law: F = -k * x)
                const springForce = direction.multiply(-this.k * displacement * this.stiffness);
                
                // Damping force (proportional to velocity difference)
                const relativeVelocity = this.mass2.velocity.subtract(this.mass1.velocity);
                const dampingForce = direction.multiply(-this.damping * relativeVelocity.dot(direction));
                
                const totalForce = springForce.add(dampingForce);
                
                this.mass1.applyForce(totalForce.multiply(-1));
                this.mass2.applyForce(totalForce);
            }
            
            draw(ctx) {
                ctx.beginPath();
                ctx.moveTo(this.mass1.position.x, this.mass1.position.y);
                ctx.lineTo(this.mass2.position.x, this.mass2.position.y);
                
                // Calculate tension for color
                const displacement = this.mass1.position.distanceTo(this.mass2.position) - this.restLength;
                const tension = Math.min(Math.abs(displacement) / 15, 1);
                
                if (displacement > 0) {
                    // Stretched - red to yellow
                    const r = Math.floor(255 * tension);
                    const g = Math.floor(150 + 105 * tension);
                    ctx.strokeStyle = `rgb(${r}, ${g}, 50)`;
                } else {
                    // Compressed - blue to cyan
                    const b = Math.floor(255 * tension);
                    const g = Math.floor(150 + 105 * tension);
                    ctx.strokeStyle = `rgb(50, ${g}, ${b})`;
                }
                
                ctx.lineWidth = 2 + tension * 5;
                ctx.stroke();
            }
        }

        class SpringMassSystem {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.masses = [];
                this.springs = [];
                this.dragging = null;
                this.gravity = new Vector(0, 9.8);
                this.airResistance = 0.05;
                this.simulationSpeed = 1.0;
                this.isPaused = false;
                this.lastTime = 0;
                this.fps = 60;
                this.frames = 0;
                this.lastFpsUpdate = 0;
                this.addMassMode = false;
                this.stiffness = 1.0;
                this.tempMass = null;
                
                this.initEventListeners();
                this.resizeCanvas();
                this.createDoublePendulum();
            }
            
            resizeCanvas() {
                this.canvas.width = this.canvas.clientWidth;
                this.canvas.height = this.canvas.clientHeight;
                this.draw();
            }
            
            createDoublePendulum() {
                this.masses = [];
                this.springs = [];
                
                const centerX = this.canvas.width / 2;
                const centerY = 150;
                
                // Anchor point
                const anchor = new Mass(new Vector(centerX, centerY), 0, 10, true);
                
                // First mass
                const mass1 = new Mass(new Vector(centerX, centerY + 120), 10);
                
                // Second mass
                const mass2 = new Mass(new Vector(centerX + 80, centerY + 240), 8);
                
                // Springs
                const spring1 = new Spring(anchor, mass1, 200, 3, 120);
                const spring2 = new Spring(mass1, mass2, 180, 3, 120);
                
                this.masses.push(anchor, mass1, mass2);
                this.springs.push(spring1, spring2);
                this.updateStats();
                document.getElementById('current-preset').textContent = 'Double Pendulum';
            }
            
            createChain() {
                this.masses = [];
                this.springs = [];
                
                const anchor = new Mass(new Vector(this.canvas.width / 2, 100), 0, 10, true);
                this.masses.push(anchor);
                
                const segmentCount = 8;
                const segmentLength = 50;
                
                for (let i = 0; i < segmentCount; i++) {
                    const mass = new Mass(
                        new Vector(this.canvas.width / 2, 150 + i * segmentLength),
                        i === segmentCount - 1 ? 15 : 8
                    );
                    
                    this.masses.push(mass);
                    
                    // Connect to previous mass
                    const prevMass = i === 0 ? anchor : this.masses[this.masses.length - 2];
                    const spring = new Spring(prevMass, mass, 200, 2, segmentLength);
                    this.springs.push(spring);
                }
                this.updateStats();
                document.getElementById('current-preset').textContent = 'Chain';
            }
            
            createGrid() {
                this.masses = [];
                this.springs = [];
                
                const rows = 5;
                const cols = 5;
                const spacing = 60;
                const startX = (this.canvas.width - (cols - 1) * spacing) / 2;
                const startY = 150;
                
                // Create masses in grid
                for (let y = 0; y < rows; y++) {
                    for (let x = 0; x < cols; x++) {
                        const fixed = y === 0;
                        const mass = new Mass(
                            new Vector(startX + x * spacing, startY + y * spacing),
                            fixed ? 0 : 5,
                            8,
                            fixed
                        );
                        this.masses.push(mass);
                    }
                }
                
                // Create springs - horizontal
                for (let y = 0; y < rows; y++) {
                    for (let x = 0; x < cols - 1; x++) {
                        const idx1 = y * cols + x;
                        const idx2 = y * cols + x + 1;
                        const spring = new Spring(this.masses[idx1], this.masses[idx2], 180, 2);
                        this.springs.push(spring);
                    }
                }
                
                // Create springs - vertical
                for (let y = 0; y < rows - 1; y++) {
                    for (let x = 0; x < cols; x++) {
                        const idx1 = y * cols + x;
                        const idx2 = (y + 1) * cols + x;
                        const spring = new Spring(this.masses[idx1], this.masses[idx2], 180, 2);
                        this.springs.push(spring);
                    }
                }
                
                // Create diagonal springs for stability
                for (let y = 0; y < rows - 1; y++) {
                    for (let x = 0; x < cols - 1; x++) {
                        const idx1 = y * cols + x;
                        const idx2 = (y + 1) * cols + x + 1;
                        const spring1 = new Spring(this.masses[idx1], this.masses[idx2], 150, 2);
                        
                        const idx3 = y * cols + x + 1;
                        const idx4 = (y + 1) * cols + x;
                        const spring2 = new Spring(this.masses[idx3], this.masses[idx4], 150, 2);
                        
                        this.springs.push(spring1, spring2);
                    }
                }
                this.updateStats();
                document.getElementById('current-preset').textContent = 'Grid';
            }
            
            createSoftBody() {
                this.masses = [];
                this.springs = [];
                
                const centerX = this.canvas.width / 2;
                const centerY = 200;
                const radius = 80;
                const pointCount = 12;
                
                // Create central mass
                const centerMass = new Mass(new Vector(centerX, centerY), 15);
                this.masses.push(centerMass);
                
                // Create surrounding masses
                for (let i = 0; i < pointCount; i++) {
                    const angle = (i / pointCount) * Math.PI * 2;
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;
                    
                    const mass = new Mass(new Vector(x, y), 5);
                    this.masses.push(mass);
                    
                    // Connect to center
                    const spring = new Spring(centerMass, mass, 120, 2);
                    this.springs.push(spring);
                    
                    // Connect to neighbors
                    const nextIdx = (i + 1) % pointCount;
                    const nextMass = this.masses[1 + nextIdx];
                    const neighborSpring = new Spring(mass, nextMass, 100, 2);
                    this.springs.push(neighborSpring);
                }
                
                // Add cross springs for stability
                for (let i = 0; i < pointCount; i++) {
                    const oppositeIdx = (i + pointCount / 2) % pointCount;
                    const mass1 = this.masses[1 + i];
                    const mass2 = this.masses[1 + oppositeIdx];
                    
                    const spring = new Spring(mass1, mass2, 80, 2);
                    this.springs.push(spring);
                }
                this.updateStats();
                document.getElementById('current-preset').textContent = 'Soft Body';
            }
            
            createBridge() {
                this.masses = [];
                this.springs = [];
                
                const bridgeLength = 8;
                const span = 80;
                const startX = (this.canvas.width - (bridgeLength - 1) * span) / 2;
                const y = 200;
                
                // Create anchor points
                const leftAnchor = new Mass(new Vector(startX - 50, y - 100), 0, 10, true);
                const rightAnchor = new Mass(new Vector(startX + bridgeLength * span, y - 100), 0, 10, true);
                this.masses.push(leftAnchor, rightAnchor);
                
                // Create bridge deck
                for (let i = 0; i < bridgeLength; i++) {
                    const mass = new Mass(
                        new Vector(startX + i * span, y),
                        i === 0 || i === bridgeLength - 1 ? 10 : 5
                    );
                    this.masses.push(mass);
                    
                    // Connect to previous deck mass
                    if (i > 0) {
                        const prevMass = this.masses[this.masses.length - 2];
                        const spring = new Spring(prevMass, mass, 250, 3, span);
                        this.springs.push(spring);
                    }
                    
                    // Connect to anchors with suspension
                    if (i === 0) {
                        this.springs.push(new Spring(leftAnchor, mass, 180, 2));
                    }
                    if (i === bridgeLength - 1) {
                        this.springs.push(new Spring(rightAnchor, mass, 180, 2));
                    }
                }
                
                // Add cross-bracing for stability
                for (let i = 0; i < bridgeLength - 1; i++) {
                    const mass1 = this.masses[i + 2]; // First deck mass is at index 2
                    const mass2 = this.masses[i + 3];
                    this.springs.push(new Spring(mass1, mass2, 150, 2, span * Math.sqrt(2)));
                }
                
                this.updateStats();
                document.getElementById('current-preset').textContent = 'Suspension Bridge';
            }
            
            createElasticNet() {
                this.masses = [];
                this.springs = [];
                
                const rows = 6;
                const cols = 6;
                const spacing = 50;
                const startX = (this.canvas.width - (cols - 1) * spacing) / 2;
                const startY = 150;
                
                // Create masses in grid
                for (let y = 0; y < rows; y++) {
                    for (let x = 0; x < cols; x++) {
                        const fixed = (y === 0 && (x === 0 || x === cols-1)) || 
                                     (y === rows-1 && (x === 0 || x === cols-1));
                        const mass = new Mass(
                            new Vector(startX + x * spacing, startY + y * spacing),
                            fixed ? 0 : 3,
                            6,
                            fixed
                        );
                        this.masses.push(mass);
                    }
                }
                
                // Create springs - horizontal
                for (let y = 0; y < rows; y++) {
                    for (let x = 0; x < cols - 1; x++) {
                        const idx1 = y * cols + x;
                        const idx2 = y * cols + x + 1;
                        const spring = new Spring(this.masses[idx1], this.masses[idx2], 120, 1.5);
                        this.springs.push(spring);
                    }
                }
                
                // Create springs - vertical
                for (let y = 0; y < rows - 1; y++) {
                    for (let x = 0; x < cols; x++) {
                        const idx1 = y * cols + x;
                        const idx2 = (y + 1) * cols + x;
                        const spring = new Spring(this.masses[idx1], this.masses[idx2], 120, 1.5);
                        this.springs.push(spring);
                    }
                }
                
                // Create diagonal springs
                for (let y = 0; y < rows - 1; y++) {
                    for (let x = 0; x < cols - 1; x++) {
                        const idx1 = y * cols + x;
                        const idx2 = (y + 1) * cols + x + 1;
                        const spring1 = new Spring(this.masses[idx1], this.masses[idx2], 80, 1.2);
                        
                        const idx3 = y * cols + x + 1;
                        const idx4 = (y + 1) * cols + x;
                        const spring2 = new Spring(this.masses[idx3], this.masses[idx4], 80, 1.2);
                        
                        this.springs.push(spring1, spring2);
                    }
                }
                this.updateStats();
                document.getElementById('current-preset').textContent = 'Elastic Net';
            }
            
            initEventListeners() {
                window.addEventListener('resize', () => this.resizeCanvas());
                
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseup', () => this.handleMouseUp());
                this.canvas.addEventListener('click', (e) => this.handleClick(e));
                
                // Physics controls
                document.getElementById('gravity').addEventListener('input', (e) => {
                    this.gravity.y = parseFloat(e.target.value);
                    document.getElementById('gravity-value').textContent = this.gravity.y.toFixed(1);
                });
                
                document.getElementById('springConstant').addEventListener('input', (e) => {
                    const k = parseFloat(e.target.value);
                    this.springs.forEach(spring => spring.k = k);
                    document.getElementById('springConstant-value').textContent = k;
                });
                
                document.getElementById('damping').addEventListener('input', (e) => {
                    const damping = parseFloat(e.target.value);
                    this.springs.forEach(spring => spring.damping = damping);
                    document.getElementById('damping-value').textContent = damping.toFixed(1);
                });
                
                document.getElementById('airResistance').addEventListener('input', (e) => {
                    this.airResistance = parseFloat(e.target.value);
                    document.getElementById('airResistance-value').textContent = this.airResistance.toFixed(3);
                });
                
                document.getElementById('simulationSpeed').addEventListener('input', (e) => {
                    this.simulationSpeed = parseFloat(e.target.value);
                    document.getElementById('simulationSpeed-value').textContent = this.simulationSpeed.toFixed(1);
                });
                
                document.getElementById('stiffness').addEventListener('input', (e) => {
                    this.stiffness = parseFloat(e.target.value);
                    this.springs.forEach(spring => spring.stiffness = this.stiffness);
                    document.getElementById('stiffness-value').textContent = this.stiffness.toFixed(2);
                });
                
                document.getElementById('pauseBtn').addEventListener('click', () => {
                    this.togglePause();
                });
                
                document.getElementById('resetBtn').addEventListener('click', () => {
                    this.createDoublePendulum();
                });
                
                document.getElementById('addMassBtn').addEventListener('click', () => {
                    this.addMassMode = !this.addMassMode;
                    this.tempMass = null;
                    this.updateAddButton();
                });
                
                // Preset buttons
                document.querySelectorAll('.preset-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const preset = btn.dataset.preset;
                        switch(preset) {
                            case 'double-pendulum':
                                this.createDoublePendulum();
                                break;
                            case 'chain':
                                this.createChain();
                                break;
                            case 'grid':
                                this.createGrid();
                                break;
                            case 'soft':
                                this.createSoftBody();
                                break;
                            case 'bridge':
                                this.createBridge();
                                break;
                            case 'net':
                                this.createElasticNet();
                                break;
                        }
                    });
                });
                
                // Spacebar to pause
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'Space') {
                        this.togglePause();
                        e.preventDefault();
                    }
                });
            }
            
            togglePause() {
                this.isPaused = !this.isPaused;
                document.getElementById('pauseBtn').innerHTML = 
                    this.isPaused ? '<i class="fas fa-play"></i> Resume' : '<i class="fas fa-pause"></i> Pause';
            }
            
            updateAddButton() {
                const btn = document.getElementById('addMassBtn');
                if (this.addMassMode) {
                    btn.innerHTML = '<i class="fas fa-times"></i> Cancel';
                    btn.style.background = 'linear-gradient(to right, #f44336, #ff7675)';
                } else {
                    btn.innerHTML = '<i class="fas fa-plus-circle"></i> Add Mass';
                    btn.style.background = 'linear-gradient(to right, #4caf50, #66bb6a)';
                }
            }
            
            handleMouseDown(e) {
                if (this.addMassMode) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Find and select a mass
                for (let i = this.masses.length - 1; i >= 0; i--) {
                    const mass = this.masses[i];
                    if (mass.fixed) continue;
                    
                    const dx = mass.position.x - x;
                    const dy = mass.position.y - y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance <= mass.radius) {
                        mass.selected = true;
                        this.dragging = mass;
                        mass.velocity = new Vector(); // Stop motion when grabbed
                        break;
                    }
                }
            }
            
            handleMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                if (this.dragging) {
                    this.dragging.position.x = x;
                    this.dragging.position.y = y;
                }
                
                if (this.addMassMode) {
                    if (!this.tempMass) {
                        this.tempMass = new Mass(new Vector(x, y), 5);
                        this.tempMass.temp = true;
                    } else {
                        this.tempMass.position.x = x;
                        this.tempMass.position.y = y;
                    }
                }
            }
            
            handleMouseUp() {
                if (this.dragging) {
                    this.dragging.selected = false;
                    this.dragging = null;
                }
            }
            
            handleClick(e) {
                if (!this.addMassMode) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Create new mass
                const newMass = new Mass(new Vector(x, y), 5);
                this.masses.push(newMass);
                
                // Create spring to nearest mass if there is one
                let nearestMass = null;
                let minDistance = Infinity;
                
                for (const mass of this.masses) {
                    if (mass === newMass || mass.temp) continue;
                    
                    const distance = newMass.position.distanceTo(mass.position);
                    if (distance < minDistance && distance < 200) {
                        minDistance = distance;
                        nearestMass = mass;
                    }
                }
                
                if (nearestMass) {
                    this.springs.push(new Spring(nearestMass, newMass, 150, 2));
                }
                
                this.updateStats();
                this.tempMass = null;
            }
            
            update(dt) {
                if (this.isPaused) return;
                
                // Apply forces
                for (const mass of this.masses) {
                    if (mass.fixed) continue;
                    
                    // Gravity
                    mass.applyForce(this.gravity.multiply(mass.mass));
                    
                    // Air resistance (damping)
                    const airResistanceForce = mass.velocity.multiply(-this.airResistance);
                    mass.applyForce(airResistanceForce);
                }
                
                // Update springs
                for (const spring of this.springs) {
                    spring.update();
                }
                
                // Update masses
                for (const mass of this.masses) {
                    mass.update(dt * this.simulationSpeed);
                }
                
                // Boundary constraints
                for (const mass of this.masses) {
                    if (mass.fixed) continue;
                    
                    // Bounce off walls
                    const bounceFactor = 0.8;
                    
                    if (mass.position.x < mass.radius) {
                        mass.position.x = mass.radius;
                        mass.velocity.x *= -bounceFactor;
                    } else if (mass.position.x > this.canvas.width - mass.radius) {
                        mass.position.x = this.canvas.width - mass.radius;
                        mass.velocity.x *= -bounceFactor;
                    }
                    
                    if (mass.position.y < mass.radius) {
                        mass.position.y = mass.radius;
                        mass.velocity.y *= -bounceFactor;
                    } else if (mass.position.y > this.canvas.height - mass.radius) {
                        mass.position.y = this.canvas.height - mass.radius;
                        mass.velocity.y *= -bounceFactor;
                    }
                }
            }
            
            draw() {
                const ctx = this.ctx;
                ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw grid background
                ctx.strokeStyle = 'rgba(64, 224, 208, 0.1)';
                ctx.lineWidth = 1;
                const gridSize = 40;
                
                for (let x = 0; x < this.canvas.width; x += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, this.canvas.height);
                    ctx.stroke();
                }
                
                for (let y = 0; y < this.canvas.height; y += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(this.canvas.width, y);
                    ctx.stroke();
                }
                
                // Draw springs
                for (const spring of this.springs) {
                    spring.draw(ctx);
                }
                
                // Draw masses
                for (const mass of this.masses) {
                    mass.draw(ctx);
                }
                
                // Draw temporary mass in add mode
                if (this.tempMass) {
                    this.tempMass.draw(ctx);
                    
                    // Draw connection line to nearest mass
                    let nearestMass = null;
                    let minDistance = Infinity;
                    
                    for (const mass of this.masses) {
                        if (mass.temp) continue;
                        
                        const distance = this.tempMass.position.distanceTo(mass.position);
                        if (distance < minDistance) {
                            minDistance = distance;
                            nearestMass = mass;
                        }
                    }
                    
                    if (nearestMass) {
                        ctx.beginPath();
                        ctx.moveTo(this.tempMass.position.x, this.tempMass.position.y);
                        ctx.lineTo(nearestMass.position.x, nearestMass.position.y);
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 3]);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }
                }
                
                // Draw info
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`Spring Mass System Simulation`, 20, 30);
            }
            
            updateStats() {
                document.getElementById('mass-count').textContent = this.masses.length;
                document.getElementById('spring-count').textContent = this.springs.length;
            }
            
            animate(timestamp) {
                this.frames++;
                
                // Calculate FPS every second
                if (timestamp - this.lastFpsUpdate >= 1000) {
                    this.fps = Math.round((this.frames * 1000) / (timestamp - this.lastFpsUpdate));
                    this.lastFpsUpdate = timestamp;
                    this.frames = 0;
                    document.getElementById('fps').textContent = this.fps;
                }
                
                if (!this.lastTime) this.lastTime = timestamp;
                const dt = (timestamp - this.lastTime) / 1000;
                this.lastTime = timestamp;
                
                this.update(dt);
                this.draw();
                
                requestAnimationFrame((ts) => this.animate(ts));
            }
            
            start() {
                this.animate(0);
            }
        }
        window.addEventListener('load', () => {
            const canvas = document.getElementById('simulationCanvas');
            const system = new SpringMassSystem(canvas);
            system.start();
        });
    </script>
</body>
</html>
